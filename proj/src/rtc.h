#pragma once

/** @defgroup rtc rtc
 * @{
 *
 * Module that interfaces with the RTC.
 */

#include "lcom/lcf.h"

#include "rtc_macros.h"

/**
 * @brief Converts the variable indexed by pointer value from Binary-coded decimal to decimal
 * 
 * @param value Pointer to the value we want to convert
 */
void convert_BCD_decimal(uint8_t *value);
/**
 * @brief Converts the variable indexed by pointer value from decimal to Binary-coded decimal
 * 
 * @param value Pointer to the value we want to convert
 */
void convert_decimal_BCD(uint8_t *value);
/**
 * @brief Subscribes to rtc interrupts
 * 
 * @param rtc_id Contains the value we are going to use to identificate rtc's interrupts
 * 
 * @return int Returns FAIL (0) if it was successful and SUCCESS (1) if it failed
 */
int rtc_subscribe_interrupt(uint8_t rtc_id);
/**
 * @brief Unsubscribes to rtc interrupts
 * 
 * @return int Returns FAIL (0) if it was successful and SUCCESS (1) if it failed
 */
int rtc_unsubscribe_interrupt();
/**
 * @brief Writes information passed as value to the register indicated by the address
 * 
 * @param address Address of the register we wish to write in
 * @param value Content we want to write in the register
 * 
 * @return int Returns FAIL (0) if it was successful and SUCCESS (1) if it failed
 */
int rtc_writeInfo(uint8_t address, uint8_t value);
/**
 * @brief Read the content stored in register indicated by the address and returns the information through the pointer value
 * 
 * @param address Address of the register we wish to read
 * @param value Points to the variable we wish to write the information to
 * 
 * @return int Returns FAIL if it was successful and SUCCESS if it failed
 */
int rtc_readInfo(uint8_t address, uint8_t * value);
/**
 * @brief Subscribes to alarm interrupts generated by the rtc
 * 
 * @return int Returns FAIL if it was successful and SUCCESS if it failed
 */
int enable_alarm();
/**
 * @brief Unsubscribes to alarm interrupts generated by the rtc
 * 
 * @return int Returns FAIL if it was successful and SUCCESS if it failed
 */
int disable_alarm();
/**
 * @brief Unsubscribes to periodic interrupts generated by the rtc
 * 
 * @return int Returns FAIL if it was successful and SUCCESS if it failed
 */
int disable_periodic();
/**
 * @brief Subscribes to update interrupts generated by the rtc
 * 
 * @return int Returns FAIL if it was successful and SUCCESS if it failed
 */
int enable_update();
/**
 * @brief Unsubscribes to update interrupts generated by the rtc
 * 
 * @return int Returns FAIL if it was successful and SUCCESS if it failed
 */
int disable_update();
/**
 * @brief Reads and handles the interrupts generated by the rtc
 * 
 * @return int Returns FAIL (0) if the operation failed, UNIMPORTANT (1) if the interrupt generated was of no interest (it was neither an update nor an alarm), ALARM_RING (2) if generated by the alarm and UPDATE (3) if by rtc's update
 */
int rtc_ih();
/**
 * @brief Requests the status in register A to verify if the UIP flag is set
 * 
 * @return int Returns FAIL if it was unsuccessful, and a bitwise operation AND in order to check if the UIP bit of the status is set
 */
int get_UIPflag();
/**
 * @brief By accessing the right register (where the day, month and year are represented), it reads and retrieves through parameters the day, month and year of the current date
 * 
 * @return int Returns FAIL if it was successful and SUCCESS if it failed
 */
int get_date(uint8_t *day, uint8_t *month, uint8_t *year);
/**
 * @brief Simple function very similar to get_time(), however it is only interested in knowing the current seconds and retrieves it as an unsigned
 * 
 * @return unsigned Returns the current seconds as an unsigned to be read outside
 */
unsigned get_seconds();
/**
 * @brief By accessing the right register (where the seconds, minutes and hours are represented), it reads and retrieves through parameters the seconds, minutes and hours of the current time
 * 
 * @return int Returns FAIL if it was successful and SUCCESS if it failed
 */
int get_time(uint8_t *second, uint8_t *minute, uint8_t *hour);
/**
 * @brief Sets an alarm to a number of seconds (received by parameter time) after the current registered time
 * 
 * @param time Number of seconds we want to wait for the alarm ring, starting from the current time
 * 
 * @return int Returns FAIL if it was successful and SUCCESS if it failed
 */
int set_alarm(uint8_t time);

/** @} */
